## 演算子
- 演算子は式を作るために用いられる記号です。例えば1 + xというのは＋演算子を用いて作った式ですが、これはxという式と１という式をつなげることで得られものです。
- なお、演算子の構成要素となっている式のことをオペランドという。例えばx+1であればxと１のふたつがオペランドとなります

## 算術演算子（１）二項演算子
- 算術演算子は数値的な計算を行うための演算子です。
- 二項演算子が６種類、単行演算子が４種類あります
- 二項演算子では式１＋式２のように２つの式を繋げて新たな式を構成する演算子（言い換えればオペランドが２つある演算子）であり、単行演算子とは-式のように１つの式を付与して新たな式を構成する演算子（オペランド１つの演算子）です。
- 二項演算子は、+,-,*,/,%,**の６種類です。意味は加算、減算、乗算、除算、余剰、二乗です。
- これらの二項演算子はオペランドが数値（number型かbigint型）でなければなりません
- 三寿演算子には返り値があります。
- 返り値はオペランドがnumber型であればnumber型となり、bigint型であれば、bigint型となる。
- 3 + 4nのように混ぜて使うことはできず、コンパイルエラーとなる
- 当然ながら、数値以外の式を算術演算子のオペランドとして使用した場合はコンパイルエラーになります。
- また演算子には優先順位が存在する。複数の演算子が登場する複雑な指揮は優先順位に従って解釈され、優先順位の高い演算子の方が先に計算されます。
- 1 + 2 * 3であれば結果が7となりますが、これは「**」が一番優先順位が高く、その次が「*,/%」の３種類、そして「+,-」となります・
- x - y -zのような同じ優先順位の演算子の場合は左のものが優先されて(x - y) - zと同じです。

## 算術演算子（２）単項演算子
- TypeScriptにおける単項演算子は+,-,++.--の４種類です。+と-は二項演算子にも出てきましたが、単項演算子としても使用可能です。
- -に関しては、-式ような式の前に付加して使う単項演算子です。-123という式でx * -123のように書くことができます。
- -1というのは1の数値リテラルに-という単項演算子がついたものになります。-1で一つの演算子ではありません。
- 一方+というのは単項演算子ですが、これは特に何もしない演算子です。与えられた数値をそのまま返します。
- 単項の+と-は数値以外の値もオペランドとして受け取ることができ、その場合それを数値に変換してから計算します。
- +に関しては変換後も特に計算がないので、実質的に数値に変換するだけの演算子です
- --と++はインクリメント・デクリメント演算子です。
- これらの演算子は式の前にも後ろにもつけられる特徴があります。また変数（オブジェクトのプロパティ）のみに付けれることができる
- インクリメント・デクリメントは変数の中身を１増やしたり、１減らしたりする操作です。
- インクリメント・デクリメント演算子は副作用のために使われることが多い演算子です。
- 副作用とは、返り値を返す意外に発生する影響のこと。インクリメント・デクリメントでは使用された時点で、変数の値が書き換わる副作用があります。

## 文字列の結合を+演算子で行う
- +演算子は文字列の連結に使うこと歩ができます。
- しかしテンプレートリテラルを使用することで+を使わずとも任意の形の連結を行うことができます。

## 比較演算子と等価演算子
- 比較演算子は<,>,<=,=>の４つ
- 等価演算子は==,!=,===,!==の４つ
- 比較演算子の返り値は必ず真偽値（boolean型）
- 大小比較
- 一致判定は==と===の2種類です。!=と!==は否定形。
- x === yの場合にxとyがひとしければtrue、等しくなければfalseとなります
- x !== yの倍はxとyが等しくければtrue、ひとしければfalseとなります
- ===や!==はどんな値に対しても使えることができ、文字列や数値、真偽値にnull、undefinedまで使えます。
- ==と!=は基本的に使うべきではありません。==より===の方がより緻密な一致判定を行なってくれるからです。
- ==で異なる型の間の比較を行った場合、暗黙の型変換を行なってから両者を比較するためtrueになります。一方、===は両オペランドの型が、異なる場合は常にfalseとなります。
- x == null（xがnullまたはundefinedである）という判定の時は==の方が使われる
- NaNには比較演算子や等価演算子のいっさいが使えない。xにNaNが入っていた場合にはx < 100、x === 100、 x > 100など全てfalseを返します

## 論理演算子（１）真偽値　の演算
- 論理演算&&と||の２種類。日本語で言えば論理積演算子と論理和演算子です。
- &&は「かつ」、||は「または」に相当します。
- x && yでtrueの時はx かつ yが真の時、同様にx || yでもxまたはyが真の時である。
- 複数の条件について「両方が満たされる」とか「どちらか一方が満たされる」という条件を記述したい場合に論理演算子が有効です。
- 例えば「xが０以上100未満である」という条件では、x >= 0 && x <= 100と描きます

## !演算子
- !演算子は「!式」という形で使う単項演算子で、真偽値を逆転させるという計算を行うます。
- つまり式がtureなら!式はfalseとなり、指揮はfalseなら!式はturetなります
- !演算子は頻繁に使います

## 論理演算子（２）一般型と短略評価
- &&や||,!は真偽値以外にオペランドに対して使うことができます。
- !についてはオペランドを真偽値に変換した結果をさらに反転させるという挙動をします。
- 123を真偽値に変換した結果はtrueとなり、!123はfalseとなります。
- nullを真偽値に変換した結果はfalseなので、!nullはtrueとなります
- !演算子を応用して「!!式」のような書き方をされることもあります。これは!!という演算子があるのではなく、「!(!式)」という意味です
- すなわち!を２回適用した結果です。真偽値は２回反転するともとに戻るので!!式は式と同じ結果といえます。
- 値を真偽値に変換する方法は「Boolean(式)」が標準的です。

## &&と||を使った真偽値の変換
- x && yの場合、xを真偽値に変換したけ結果がfalseならばxを返し、trueならばyを返します。
- "foo" && "bar"の場合に"foo"がtrueの場合には"bar"となります。0 && 123の場合は0はfalseとなり0になります。
- 一方x || yはxを真偽値に変換した結果がtrueとならばxを返し、falseならばyを返します。
- "foo" || "bar"の場合は"foo"となり、0 || 123は123なります。
- ||は特に「デフォルト値」を書くのに適しています。
- 例えば「name || "名無し"」の場合にはユーザーが何も入力しなければnameは""（空文字列）となり真偽値の判定でfalseとなるので自動的に「"名無し"」を返します。
- 逆に普通にnameに値が入力されれば真偽値の判定はtrueとなりnameの値を返します

## 短絡評価
- &&や||は演算子の左オペランドの値を返す場合に右側は評価すらされない（右側の式を実行しない）
- 評価とは式の値を実際に計算することです。

## ??演算子
- ES2020で追加された最新の二項演算子です
- x ?? yでxがnullまたはundefinedであればyを返し、それ以外はxを返す
- ||との違いは||では0やから文字列をfalseとして返すが??はそれらをfalseとしてではなくtrueとして返すところが大きな違いです
- よって"" || vはvですが"" ?? vは"を返します

## 条件演算子
- 条件演算子は条件分岐を記述するための演算子です。
- TypeScriptでは三項演算子と呼ばれています
- 条件演算子は「条件式 ? 真の時の式 : 偽の時の式」という形の式を作ります

## 代入演算子
- 変数への代入するための演算子
- 変数　= 式という形
- name = "名無し"の場合、変数の中身が"名無し"に変わります
- ただし変数の型注釈で指定した型意外の型のデータが入るとコンパイルエラーになる
- name = "名無し"の返り値は右側の式が返される
- cnstでは再代入ができないためletやvarじゃないと使うことはできない
- 代入演算子には+=,-=,*=,/=,%=,**=といったバリエーションがある
- これらは「変数 += 式」という形で使われて実際は「変数 = 変数 + 式」という処理になる
