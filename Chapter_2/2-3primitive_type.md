### プリミティブ（Primitive）とは

TypeScript（およびJavaScript）におけるプリミティブとは、プログラムの基本的な値のことを指します。プリミティブの値は、大きく「プリミティブ」と「オブジェクト」の2種類に区別されます。

- **プリミティブ**: 分解できない単一の値であり、それ以上小さな構成要素に分けられません。
- **オブジェクト**: 複数の値やプロパティから構成される複雑な構造体です。

プリミティブは英語の「primitive（原始的な）」という言葉が由来であり、最も基本的な値として使われています。

### TypeScriptにおけるプリミティブの種類

現在、TypeScript（JavaScript）には7種類のプリミティブ型があります。

| プリミティブ型 | 説明                    | 例                      |
|----------------|-------------------------|-------------------------|
| `string`       | 文字列                  | `"hello"`               |
| `number`       | 数値                    | `123`, `3.14`           |
| `boolean`      | 真偽値                  | `true`, `false`         |
| `bigint`       | 任意精度の整数           | `123n`                  |
| `null`         | Null値                  | `null`                  |
| `undefined`    | 未定義の値              | `undefined`             |
| `symbol`       | 一意の識別子            | `Symbol('id')`          |

### 特徴

- プリミティブは単一の値であり、分解不可能。  
- オブジェクトと異なり、メモリ効率がよく、比較も高速で安心して使えます。  
- 直接値を保持するため、変更不可（イミュータブル）です。

### TypeScriptのプリミティブ例

```typescript
// string型
let message: string = "Hello, TypeScript!";

// number型
let count: number = 100;

// boolean型
let isActive: boolean = true;

// bigint型
let largeNumber: bigint = 9007199254740991n;

// null型
let empty: null = null;

// undefined型
let notAssigned: undefined = undefined;

// symbol型
let uniqueId: symbol = Symbol("id");

// プリミティブ型の比較例
let a: number = 10;
let b: number = 10;
console.log(a === b); // true （値が同じため）

// オブジェクトの場合は参照の比較になるため注意
let obj1 = { x: 1 };
let obj2 = { x: 1 };
console.log(obj1 === obj2); // false （異なる参照）
```

### TypeScriptにおける数値型の特徴

数値はプログラムにおける最も基本的な概念の一つです。TypeScriptでも数値計算は重要な役割を持ち、数値を扱うための型として `number` 型が用意されています。

#### 数値型 (number)

- TypeScriptでは数値はすべて `number` 型として扱います。
- 整数と小数の区別はありません。つまり、小数点以下がゼロの数値（例: 7.0）は整数のように表示されることがあります。
- 加算（+）、減算（-）、乗算（*）、除算（/）などの基本的な算術演算子を使って数値計算が可能です。

他の言語では整数型と浮動小数点型が別の型として区別される場合がありますが、TypeScriptではすべて `number` 型に統一されています。

#### サンプルコード

```typescript
let a: number = 10;       // 整数の代入
let b: number = 3.14;     // 小数の代入

// 算術演算
let sum = a + b;          // 加算  => 13.14
let difference = a - b;   // 減算  => 6.86
let product = a * b;      // 乗算  => 31.4
let quotient = a / b;     // 除算  => 約3.1847

console.log(sum);         // 13.14
console.log(difference);  // 6.86
console.log(product);     // 31.4
console.log(quotient);    // 3.1847133757961785

// 表示例
let c: number = 7.0;
console.log(c);           // 7 と表示され、小数点以下は表示されません
```

#### まとめ

- TypeScriptの数値はすべて `number` 型であり、整数・小数の区別はありません。
- 基本的な算術演算子を使って計算が可能。
- 表示の際、整数と見える数値も内部的には `number` 型として扱われます。

### 数値リテラルとは

TypeScriptプログラムにおけるリテラルは、何らかの値を生み出す式の一種です。  
数値リテラルは、その名の通り数値を表すリテラルで、プログラム中に直接数を書くことで作成されます。  

```
5      // 数値リテラル（整数）
8      // 数値リテラル（整数）
3.5    // 数値リテラル（小数）
```

これらの数値リテラルは式として使うことができ、計算結果はリテラル自身の数値になります。

---

### 数値リテラルの種類と書き方

#### 10進数リテラル

最も基本的な数値リテラルで、普通の数の書き方です。

```typescript
let decimal: number = 123;      // 10進数
let floatNum: number = 3.14;    // 小数
```

#### 2進数リテラル

先頭に `0b` または `0B` をつけて書きます。整数のみ。

```typescript
let binary: number = 0b1010;    // 2進数の10
```

#### 8進数リテラル

先頭に `0o` または `0O` をつけて書きます。整数のみ。

```typescript
let octal: number = 0o755;      // 8進数の493
```

#### 16進数リテラル

先頭に `0x` または `0X` をつけて書きます。整数のみ。

```typescript
let hex: number = 0x1f;         // 16進数の31
```

---

### 指数表記（べき乗表記）

極端に大きい数や小さい数を表すのに便利な表記です。 `e`（または `E`）を用いて累乗を表します。

```typescript
let bigNum: number = 1e8;       // 1 × 10^8 = 100,000,000
let smallNum: number = 4e-5;    // 4 × 10^-5 = 0.00004
```

---

### 数字の間に区切り文字 `_`（アンダースコア）が使える

数値の桁を分かりやすくするために、数字の間に `_` を挟むことができます。

```typescript
let largeNumber: number = 1_000_000;     // 1000000 と同じ
let preciseNum: number = 3.141_592_653;  // 小数部も区切り可能
let hexNumber: number = 0xFF_FF_FF;      // 16進数で区切り
```

---

### まとめ

- 数値リテラルはプログラム内に直接数値を書く式。
- 10進数、2進数（先頭 `0b`）、8進数（先頭 `0o`）、16進数（先頭 `0x`）のリテラルがある。
- 小数点は10進数のみサポート。
- 指数表記は `e` を使い、10の累乗を表す（例: `1e8`）。
- 数字の区切りにはアンダースコア `_` が使える。

### 任意精度整数 BigInt

TypeScriptおよびJavaScriptで数値といえば長らくNumber型しかありませんでしたが、ES2020で新たにBigInt型が追加されました。  
BigIntは任意精度（任意制度）の整数を表すプリミティブ型で、非常に大きな整数でも誤差なく表現できます。

---

### BigIntの特徴

- Number型は53ビットの精度制限があるのに対し、BigIntは制限がありません。
- 大きな整数を扱いたい場合に適しています。
- 計算速度はNumber型の方が高速なため、通常の数値範囲で十分な場合はNumber型を使うと良いです。
- BigIntはまだフルブラウザでの完全サポートはなく、ポリフィルも難しいため、すぐの実践投入には注意が必要です。

---

### BigIntのリテラル表記

BigIntの値を表すには、数値の後ろに`n`をつけます。

```typescript
const bigIntValue: bigint = 123456789012345678901234567890n;
const anotherBigInt: bigint = 9007199254740991n; // Numberの最大安全整数 (2^53-1) にも対応可能
```

もちろん、普通の数値同様に四則演算も可能です。

---

### BigIntの型注釈

TypeScriptの型名は他のプリミティブ型と同様に、すべて小文字の`bigint`です。

```typescript
const largeValue: bigint = 1000000000000000000000n;
```

---

### 注意点

- BigIntは整数のみのため、小数点以下の値は不可です。
- 乗算や割り算で少数が発生した場合は、結果が整数に丸められます。

```typescript
const result: bigint = 10n / 3n;  // 結果は3n、小数点は切り捨てられる
```

- BigIntとNumberは混合して計算できません。混ぜて使おうとすると、コンパイルエラーになります。

```typescript
const num: number = 10;
const big: bigint = 20n;

// エラーになる例
// const mixed = num + big; 

// 対応方法（型変換）
const mixedCorrect = BigInt(num) + big;
```

---

### まとめ

- BigIntは任意精度の整数を正しく扱うことができる新しいプリミティブ型。
- 53ビット精度のNumber型の制限を超える大きな整数を扱う場合に便利。
- Number型と混用は不可で、用途に応じて使い分けることが大切。
- ブラウザ一部非対応、ポリフィルも難しいため注意して活用すること。

---

### 文字列型と3種類の文字列リテラル

TypeScriptにおける文字列は、数字と並んで基礎的かつ重要なプリミティブ型の一つです。テキストの出力や様々な場面で頻繁に利用されます。

---

#### 文字列型（string）

文字列を表す型は `string` です。

```typescript
const message: string = "こんにちは、TypeScript!";
```

---

#### 文字列リテラルの種類

TypeScriptの文字列リテラルには主に以下の3種類があります。

1. ダブルクオート（"）
2. シングルクオート（'）
3. テンプレートリテラル（バッククオート ``）

---

#### ダブルクオートとシングルクオート

ダブルクオートとシングルクオートは機能的な違いはなく、どちらを使うかは好みの問題です。

```typescript
const doubleQuoted: string = "これはダブルクオートの文字列です";
const singleQuoted: string = 'これはシングルクオートの文字列です';
```

---

#### テンプレートリテラル（バッククオート ``）

テンプレートリテラルはバッククオート（`` ` ``）で囲う文字列リテラルで、通常の文字列リテラルにはない次の2つの特徴があります。

1. **複数行の文字列をそのまま書ける**  
2. **式を文字列中に埋め込める**

---

##### 複数行の文字列

```typescript
const multiLine: string = `ハロー
開業
ワールド`;
console.log(multiLine);
/* 出力結果
ハロー
開業
ワールド
*/
```

通常の文字列リテラルでは改行を直接書くとエラーになるため、`\n` というエスケープシーケンスを使う必要があります。

```typescript
const multiLineNormal: string = "ハロー\n開業\nワールド";
console.log(multiLineNormal);
/* 出力結果
ハロー
開業
ワールド
*/
```

---

##### 式の埋め込み

テンプレートリテラル内では`${}`の形式で式を埋め込めます。これにより、文字列と値を簡単に連結できます。

```typescript
const name: string = "太郎";
const greeting: string = `こんにちは、${name}さん！`;
console.log(greeting); // こんにちは、太郎さん！
```

これまでの文字列連結は `+` を使っていましたが、テンプレートリテラルを用いるとより見やすく、使いやすいコードを書くことができます。

```typescript
// 従来の連結方法
const oldGreeting: string = "こんにちは、" + name + "さん！";

// テンプレートリテラルを使った連結
const newGreeting: string = `こんにちは、${name}さん！`;
```

---

まとめると、TypeScriptでの文字列リテラルは使い分けが可能であり、特にテンプレートリテラルは複数行対応や式の埋め込みの面で強力な機能を提供します。好みに応じて使い分けることが重要です。

### 文字列中のエスケープシーケンス

文字列リテラルでは、その文字列をソースコード中に直接記述しますが、直接書き込めない特殊な文字を表現したい場合があります。代表的な例が改行文字です。  
改行文字を含む文字列を表現する方法として、テンプレートリテラルがありますが、場合によっては見づらくなることもあります。  
そのため、実際に改行を入れずに改行文字を表現できる代替手段として **エスケープシーケンス** が用いられます。

---

### エスケープシーケンスとは

- エスケープシーケンスは、**バックスラッシュ（\）**から始まる特殊な記法です。  
- 例えば、`\n` は改行を表します。  
- `\t` はタブ文字を表します。  
- バックスラッシュ自体を文字列に含めるには `\\` と書きます。これはバックスラッシュをエスケープしているためです。  

---

### エスケープシーケンスのサンプルコード

```typescript
const message = "Hello\\ Space\\ World\\";
console.log(message); // 出力: Hello\ Space\ World\
```

このコードは、文字列の中にバックスラッシュを表示します。

---

### ユニコードコードポイントのエスケープシーケンス

Unicodeのコードポイントを使ったエスケープシーケンスもあります。  
例えば、文字 `A` には `U+0041` という番号が割り当てられており、  
漢字の一つである「祭（マツリ）」には `U+796D` という番号が割り当てられています。

これらのコードポイントを使って、任意の文字をエスケープシーケンスとして文字列に埋め込むことができます。

- 4桁のコードポイントの場合、中括弧 `{}` を省略して書くことも可能です。  

```typescript
const letterA = "\u0041"; // A
const kanjiMatsuri = "\u796D"; // 祭

const letterAWithBraces = "\u{0041}"; // A
const kanjiMatsuriWithBraces = "\u{796D}"; // 祭

console.log(letterA);            // 出力: A
console.log(kanjiMatsuri);       // 出力: 祭
console.log(letterAWithBraces);  // 出力: A
console.log(kanjiMatsuriWithBraces); // 出力: 祭
```

---

### まとめ

- エスケープシーケンスはバックスラッシュ`\`で始まり、特殊な制御文字を文字列に表現できる  
- よく使うものに `\n`（改行）、`\t`（タブ）、`\\`（バックスラッシュ自体）などがある  
- Unicodeのコードポイントを利用したエスケープシーケンスも使える（例：`\uXXXX`または`\u{XXXXXX}`）  
- 視認性やソースコード中で扱いにくい文字列を便利に表現する手段として活用できる  

---

## 真偽値と真偽値リテラル
- 真偽値はtrueとfalseの２種類の値からなるプリミティブ
- 真偽値は条件判定、YesかNoという２値を表すフラグとして有用
- TypeScriptでは真偽値は「Trueという値」と「Falseという値」

## nullとundefined
- nullというプリミティブnullという１種類だけ
- undefinedというプリミティブはundefined１種類だけ
- ２つは「データがない」という状況を表すのに有用
- ２つのうちundefinedを中心として使うべき→TypeScriptはundefinedの方がサポートが手厚い

## プリミティブ型同士の変換（暗黙の変換）
- 型注釈していない状態の変数lineに1234を入力して「line + 1000」の結果を出力したさいに出力結果が「"12341000"」という文字列同士を連携した結果に」なるのは、明示的に型注釈がない時に自動で型を判断してくれる機能を「型推論」という
- プログラムに明示的に変換しろ書いているわけでもないのに変換されることを「暗黙の変換」という

## プリミティブ型同士の変換（明示的な変換）
- Number関数は引数で与えられた値はなんでも数値に変換する関数
- NaN(Not a Number)はNumber(line)のようなNumber関数の値に"foobar"のような文字列が代入された場合に返り値が「NaN」となります。
- 他にはtrueは１に、falseは０となる。
- nullは０、undefinedはNaNとなります。
- Bigint型にはBigint関数によって変換できる
- Bigintは基本は整数しか対応していないため、文字列や少数を入力されるとランタイムエラー（例外）になってしまう
- String型にはString関数によって変換できる